setFilePerms(){
    if [ -f $PIDSPATH/$PIDFILE ]; then
        chmod 400 $PIDSPATH/$PIDFILE
    fi
}

configtest() {
    $DAEMON -t -c $NGINX_CONF_FILE
}

getPSCount() {
    return `pgrep -f $PS | wc -l`
}

isRunning() {
    if [ $1 ]; then
        pidof_daemon $1
        PID=$?

        if [ $PID -gt 0 ]; then
            return 1
        else
            return 0
        fi
    else
        pidof_daemon
        PID=$?

        if [ $PID -gt 0 ]; then
            return 1
        else
            return 0
        fi
    fi
}

#courtesy of php-fpm
wait_for_pid () {
    try=0

    while test $try -lt 35 ; do
        case "$1" in
            'created')
            if [ -f "$2" ]; then
                try=''
                break
            fi
            ;;

            'removed')
            if [ ! -f "$2" ]; then
                try=''
                break
            fi
            ;;
        esac

        try=`expr $try + 1`
        sleep 1
    done
}

status(){
    isRunning
    isAlive=$?

    if [ "${isAlive}" -eq $TRUE ]; then
        log_warning_msg "$DESCRIPTION found running with processes:  `pidof $PS`"
        rc=0
    else
        log_warning_msg "$DESCRIPTION is NOT running."
        rc=3
    fi

    return
}

removePIDFile(){
    if [ $1 ]; then
        if [ -f $1 ]; then
            rm -f $1
        fi
    else
        #Do default removal
        if [ -f $PIDSPATH/$PIDFILE ]; then
            rm -f $PIDSPATH/$PIDFILE
        fi
    fi
}

start() {
    log_daemon_msg "Starting $DESCRIPTION"

    isRunning
    isAlive=$?

    if [ "${isAlive}" -eq $TRUE ]; then
        log_end_msg $SCRIPT_ERROR
        rc=0
    else
        start-stop-daemon --start --quiet --chuid \
        $RUNAS --pidfile $PIDSPATH/$PIDFILE --exec $DAEMON \
        -- -c $NGINX_CONF_FILE
        status=$?
        setFilePerms

        if [ "${status}" -eq 0 ]; then
            log_end_msg $SCRIPT_OK
            rc=0
        else
            log_end_msg $SCRIPT_ERROR
            rc=7
        fi
    fi

    return
}

stop() {
    log_daemon_msg "Stopping $DESCRIPTION"

    isRunning
    isAlive=$?

    if [ "${isAlive}" -eq $TRUE ]; then
        start-stop-daemon --stop --quiet --pidfile $PIDSPATH/$PIDFILE

        wait_for_pid 'removed' $PIDSPATH/$PIDFILE

        if [ -n "$try" ]; then
            log_end_msg $SCRIPT_ERROR
            rc=0 # lsb states 1, but under status it is 2 (which is more prescriptive). Deferring to standard.
        else
            removePIDFile
            log_end_msg $SCRIPT_OK
            rc=0
        fi
    else
        log_end_msg $SCRIPT_ERROR
        rc=7
    fi

    return
}

reload() {
    configtest || return $?

    log_daemon_msg "Reloading (via HUP) $DESCRIPTION"

    isRunning

    if [ $? -eq $TRUE ]; then
        kill -HUP `cat $PIDSPATH/$PIDFILE`
        log_end_msg $SCRIPT_OK
        rc=0
    else
        log_end_msg $SCRIPT_ERROR
        rc=7
    fi

    return
}

quietupgrade() {
    log_daemon_msg "Peforming Quiet Upgrade $DESCRIPTION"

    isRunning
    isAlive=$?

    if [ "${isAlive}" -eq $TRUE ]; then
        kill -USR2 `cat $PIDSPATH/$PIDFILE`
        kill -WINCH `cat $PIDSPATH/$PIDFILE.oldbin`

        isRunning
        isAlive=$?

        if [ "${isAlive}" -eq $TRUE ]; then
            kill -QUIT `cat $PIDSPATH/$PIDFILE.oldbin`
            wait_for_pid 'removed' $PIDSPATH/$PIDFILE.oldbin
            removePIDFile $PIDSPATH/$PIDFILE.oldbin

            log_end_msg $SCRIPT_OK
            rc=0
        else
            log_end_msg $SCRIPT_ERROR

            log_daemon_msg "ERROR! Reverting back to original $DESCRIPTION"

            kill -HUP `cat $PIDSPATH/$PIDFILE`
            kill -TERM `cat $PIDSPATH/$PIDFILE.oldbin`
            kill -QUIT `cat $PIDSPATH/$PIDFILE.oldbin`

            wait_for_pid 'removed' $PIDSPATH/$PIDFILE.oldbin
            removePIDFile $PIDSPATH/$PIDFILE.oldbin

            log_end_msg $SCRIPT_OK
            rc=0
        fi
    else
        log_end_msg $SCRIPT_ERROR
        rc=7
    fi

    return
}

terminate() {
    log_daemon_msg "Force terminating (via KILL) $DESCRIPTION"

    PIDS=`pidof $PS` || true

    [ -e $PIDSPATH/$PIDFILE ] && PIDS2=`cat $PIDSPATH/$PIDFILE`

    for i in $PIDS; do
        if [ "$i" = "$PIDS2" ]; then
            kill $i
            wait_for_pid 'removed' $PIDSPATH/$PIDFILE
            removePIDFile
        fi
    done

    log_end_msg $SCRIPT_OK
    rc=0
}

destroy() {
    log_daemon_msg "Force terminating and may include self (via KILLALL) $DESCRIPTION"
    killall $PS -q >> /dev/null 2>&1
    log_end_msg $SCRIPT_OK
    rc=0
}

pidof_daemon() {
    PIDS=`pidof $PS` || true

    [ -e $PIDSPATH/$PIDFILE ] && PIDS2=`cat $PIDSPATH/$PIDFILE`

    for i in $PIDS; do
        if [ "$i" = "$PIDS2" ]; then
            return 1
        fi
    done

    return 0
}

action="$1"
case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart|force-reload)
        stop
        # if [ $rc -ne 0 ]; then
        #     script_exit
        # fi
        sleep 1
        start
        ;;
    reload)
        $1
        ;;
    status)
        status
        ;;
    configtest)
        $1
        ;;
    quietupgrade)
        $1
        ;;
    terminate)
        $1
        ;;
    destroy)
        $1
        ;;
    *)
        FULLPATH=/etc/init.d/$PS
        echo "Usage: $FULLPATH {start|stop|restart|force-reload|reload|status|configtest|quietupgrade|terminate|destroy}"
        echo "       The 'destroy' command should only be used as a last resort."
        exit 3
        ;;
esac

exit $rc